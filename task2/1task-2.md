建议阅读方式：
本文建议多读几遍，因为为了保证总体上的理解顺序一致，所以前面用到的概念后面才会详细说，第一遍先对所有概念有个印象，第二遍再前后结合根据我举的例子理解。

##什么是CSS
Cascading Style Sheet(css)是一门指定文档该如何呈现的语言。用户代理（UA）将文档以可视的形式进行呈现。所以css并非仅仅用于浏览器，浏览器只是用户代理其中之一。

##为何使用CSS
css帮助你将文档信息的内容和如何展现它的细节（样式）相分离。这样可以

* 避免重复
* 更容易维护
* 为不同的目的使用不同的样式而内容相同

##css如何工作
浏览器在展现一个文档的时候，必须要把文档内容和相应的样式信息结合起来展示。这个处理过程一般分为两个阶段：

* 浏览器先将标记语言和css转换成DOM结构，这时DOM就代表了电脑内存中的相应文档，因为它已经融合了文档内容和相应的样式表。
* 浏览器把DOM的内容展示出来。

DOM是一种树形结构，每个元素和非空文本都可以看作是树形结构上的一个节点。DOM节点不再是容器，但是它可以作为子节点的父节点而存在。理解DOM结构可以帮助你更好的设计，调试，维护css，因为DOM结构就是你的css和文档内容融合而成的。

##层叠和继承
* 样式表中元素如何父级继承样式
* 不同层级的样式如何相互作用决定最终显示效果
* 通过在样式表中添加级联样式语句，进一步控制页面元素的展现

对于层叠来说，主有三种主要样式来源：

> * 浏览器对HTML定义的默认样式
> * 用户定义的样式
> * 开发者定义的样式，可以有三种形式：
    * 定义在外部文件（外链样式）
    * 在页面头部定义（内联样式）：通过这种形式定义的样式只在本页面内生效
    * 定义在特定的元素身上（行内样式）：这种形式多用于测试，可维护性较差

开发者定义的样式（子元素自身的样式优先级高于从父元素继承来的样式）>用户定义的样式表>浏览器定义的默认样式。

> 网页上随便一个网页，有一部分样式是来自浏览器定义的默认的HTML样式。
> 
> 有一部分样式可能来自用户通过浏览器自定义的样式，或为浏览器引入自定义的样式表。在一些浏览器中用户可以自行设定网页字体和颜色，也可以建立一个单独的userContent.css样式文件并放到“用户配置”的文件夹中。（css提供了```!important```关键字，用户可以通过使用这个关键字使自己定义的样式覆盖掉开发者定义的样式）。
> 
> 还有一部分样式来自外链的服务器上的样式表。

####继承
一个文档树中一个元素的有些属性值会被其子元素继承，每个属性的**属性定义表格**分别描述了改属性会被继承与否。继承是透过文档树进行的。

当继承发生时，元素继承计算值。父元素的计算值同时成为子元素的指定值与计算值。
```css
    body{
        font-size:10pt;
    }
    h1{
        font-size:130%;
    }
```
```html
<body>
    <h1>文本</h1>
</body>
```
Chrome浏览器默认```html```的```font-size```值为```16px```，因为```16px=100%=1em=12pt```，```body```元素的```font-size```属性的指定值和计算值继承自```html```。最终的计算值是```16px*10pt/12pt=13.3333px```。```h1```元素同理继承```13.3333px```后，最终计算值为```13.33px*1.3=17.3333px```。
```javascript
window.getComputedStyle($('html')).fontSize;// "16px"
window.getComputedStyle($('body')).fontSize;// "13.3333px"
window.getComputedStyle($('h1')).fontSize;// "17.3333px"
```

####'inherit'值
每个属性都可以有```inherit```作为层叠值。```inherit```表示给定元素的指定值是该父元素的计算值。若根元素的某个属性设有```inherit```值，UA会把属性的初始值指派给该属性。

####@import规则
@import规则允许用户从其它样式表中导入样式。在css2.1中@import规则必须写在其它规则前面，这样UA才更快捷地知道何时忽略该规则。

@import关键字必须跟着要被导入的样式表URI或一个字符串（此字符串最终还是被当成url(...)包围着来解析）。
```html
    @import url("a.css");
    @import "a.css"
```
这样的效果是一样的。

作者可以指定限定媒体的@import规则，以避免UA为不支持的媒体去获取资源。只需在URI后指定以逗号分隔的媒体列表。
```html
    @import url("print.css") print;
    @import url("bluish.css") projection,tv;
    @import url("all.css")
```
第一句为打印设备指定样式表，第二句为投影和tv设备指定样式表。若没有指定媒体或指定```all```作为媒体（第三句），规则会被无条件导入。

注：如果同一个样式表被同一个文档导入或引用多次，UA必须像对待不同的样式表那样对每次引用都依次处理一遍。

####层叠
样式表有三种不同来源：网页作者，用户，用户代理。这三种来源的样式表会在网页范围内有所重叠，它们会按照层叠方式相互影响。先要理解什么是重要性，来源，特异度。

css会赋予每一条样式规则一个权重，当几条规则同时生效时，权重最大的规则优先。通常网页作者指定的样式表权重高于用户样式表，再高于UA的预设样式表。但对于指定了```!important```规则，优先次序正好反过来。

> * 层叠次序
> * !important规则
> * 计算选择器的特异度（特性值）

######层叠次序的确定
UA是怎么找出一个元素的属性值的？按照下面排序方式（这段翻译的有些难理解，那我举例子结合理解好了）：

* 1.为目标媒体类型找出所有适用于目标元素与属性的所有声明，当声明对应的选择器匹配目标元素，且目标媒体匹配包含此声明的@media规则构成的媒体列与到达该样式表的路径上的所有媒体列，则本规范称该声明适用于目标元素与属性。
现在程序员的代码如下：
```css
    h1{
        color:red;
    }
```
假设为浏览器找出所有适用于```h1```元素的```color```属性支持的所有声明，这些声明都有：```color:red```,```color:rgb(0,0,0)```,```color:#fff```等一系列(相当于要在一组集合中找出某目标项)，浏览器支持的这些声明可对应于任意的选择器，现在目标元素是名字叫```h1```的元素选择器元素，而且此时的浏览器满足是在@media规则声明的媒体列之一。

* 2.按以下优先度递增的次序根据重要性（分为一般或重要）和来源（分为网页作者，用户，UA）来排序：
    * UA声明
    * UA一般声明
    * 网页作者一般声明
    * 网页作者重要声明
    * 用户重要声明

第一步完成的只是前提步骤，在前提满足条件下进行第二步，因为除了浏览器默认支持的值之外，程序员也可以声明具体用哪个属性，就如本例程序员声明要```color:red```的这条声明，浏览器通过遍历（我猜想应该是通过这种类似方式）在```color```声明的集合中找出目标声明即```color:red```并应用到网页最后的呈现效果，所以呈现在浏览网页用户面前的是已经经过一次指定值，计算值，使用值，实际值步骤后的。除了程序员，浏览网页的用户设置重要声明可对该声明进行重定义，那就又要进行一次遍历查找过程和渲染过程了。还有一种情况就是如果用户是在浏览器加载样式表之前设置的重要声明，那么遍历查找以及那4步确定最终值这一系列过程可能只有一次。

* 3.对有相同重要性与来源的规则，按特异度来排序：比较特异的选择器会覆盖比较一般的，伪元素和伪类分别以一般元素与一般类别计算。

这步是可选的，是插在第二步中的某个可能分支条件上，如果存在程序员为同一个元素（如果相同重要性）定义了多个相同属性的声明，那么会应用（遍历筛选）哪个声明呢？
```css
    h1{
        color:red;
    }
    body h1{
        color:green;
    }
```
浏览器会计算这两种情况的特异度，选择最特异的那个作为目标项再去遍历筛选。

* 4.最后按声明出现的顺序排序：若两个声明有相同重要性，来源，特异度，则后出现的优先度较高。

这步也是可选的，是插在有相同特异度的某个可能分支条件上，也就说如果程序员是这样设置声明的。外部样式表里面的所有声明相当于出现在当前主样式表中任何声明之前，意思就是有相同重要性，来源，特异度的某元素的优先级是 外部样式表<内部样式表<内嵌样式表
```css 
    h1{
        color:red;
    }
    h1{
        color:red;
    }
```
目标项就是后来声明的那个```color:red```

######!important规则
通常网页作者样式表会覆盖用户样式表，但css尝试在网页作者样式表与用户样式表间取得权力的平衡，就有!important规则了。网页作者和用户样式表均可有该标记，但用户```!important```声明会覆盖网页作者```!important```声明。这个规则给予了用户一种控制网页呈现的主动权，以便实现特殊要求，因为这样会改进文档可读性。所以细心的同学会发现浏览器里的设置一般都会有选择字型字号颜色等选项。
```css
    /*用户样式表的一部分*/
    p{
        text-indent: 1em !important;
        font-style: italic !important;
        font-size: 18pt;
    }
    /*网页作者样式表的一部分*/
    p{
        text-indent: 1.5em !important;
        font: normal 12pt sans-serif !important;
        font-size: 24pt;
    }
```
最终目标项声明为
```css
    p{
        text-indent: 1em;
        font: italic 12pt sans-serif;
    }
```

######计算选择器的特异度（特性值）
共分为abcd四个级别，一次取值为0或1，可以想成是01组成的串，累加后高位大的数值越多，特异度越高。
> * 内联样式（如果该声明是在一个元素```style```属性中出现的）,abcd=1000
> * 一个ID选择器为abcd=0100，两个ID选择器为abcd=0200
> * 一个类选择器或属性选择器，伪类为abcd=0010 
> * 元素选择器，伪元素为abcd=0001 
> * 通用元素选择器*，后代选择器（ ）子元素选择器（>）毗邻元素选择器（+）的abcd=0000

举例：
```css
    * {} /*abcd=0000*/
    li:first-line{} /*元素:伪元素 abcd=0002*/
    ul ol+li{} /*元素 元素毗邻元素元素 abcd=0003*/
    h1+*[rel=up]{} /*元素毗邻元素通用元素属性选择器 abcd=0011*/
    style="" /*内联样式 abcd=1000*/
```

######与呈现方式相关的非css的显示特性的优先次序
这些属性会被转换成特异度为0000的规则，并当成把这些规则的声明插入到网页作者样式表的开始位置来处理，因此它们会被后继的样式表规则覆盖。

####指定值，计算值，使用值，实际值
用户代理在解析文档并构建文档树后，必须为树中每一个元素的每一个属性分派一个适用于目标媒体类型的属性值。

属性值的最终取值是经过四步计算得出的结果：
> * 由文档指定的取值（指定值）要考虑层叠和继承
> * 经过处理得到可被直接继承的取值（计算值） 计算
> * 再在必要时候转化成绝对值（使用值）有依赖的关系的计算
> * 最后根据本地环境的限制转换成最终值（实际值）UA对使用值近似处理后的结果

下面来详细解说属性值每一步的实现

* （1）指定值：用户代理必须先根据以下机制（按优先次序）为每一个属性分派指定值：
    * 1.若通过层叠得到一个值，且该值不是```inherit```，则使用这个取值
    * 2.否则，若得到的值是```inherit```，且该元素不是文档树的根，则使用父元素的计算值
    * 3.否则使用属性的初始值。每个属性的初始值都被记载在该属性的定义表格中。

有点难理解，举例来说
```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8">
    <style type="text/css">
        body{
            color: red ;
        }
        body{
            color: green ;
        }
  </style>
</head>
<body>
    文本
</body>
</html>
```

1.```body```元素的```color```属性层叠了，属性值不是```inherit```，则使用这个```green```值，所以最后效果就是```文本```呈现绿色。

2.将层叠属性的代码改为```inherit```
```html
<style type="text/css">
    body{
        color: red ;
    }
    body{
        color: inherit ;
    }
</style>
```
而且```body```又不是文档树的根，则使用父元素的计算值，因为父元素```html```默认的```color```属性值是```black```，所以```文本```最终会显示黑色。
```javascript
window.getComputedStyle($('body')).color;// "rgb(0, 0, 0)"
```

3.在以上两种情况都不符合情况下，比如层叠的```color```值是一个非法识别不了的值，这个时候就使用上一次定义的合法值。
```html
<style type="text/css">
    body{
        color: red ;
    }
    body{
        color: xx ;
    }
</style>
```
之后```文本```最终会显示红色。
```javascript
window.getComputedStyle($('body')).color;// "rgb(255, 0, 0)"
```
* （2）计算值（理想状态值）：指定值在层叠的时候经处理变成计算值（这种处理力求速度，所以不对文档进行排版）。举例来说，把URI都解析成绝对URI，把以```em```和```ex```为单位的值计算成像素值或是绝对长度值。在计算这些取值时不需要对文档进行渲染。
    * 若UA不能把某个URI解析成绝对URI则计算值仍为原指定值。
    * 属性的指定值由**属性定义表格**中计算值这一栏的方法决定。
    * 就算根据适用于这一栏的定义，一个属性为对某个元素不适用，但其计算值仍然存在（意思是计算后的值存在，但UA理解不了该值）。然而也有些属性会根据该属性是否适用于某个元素来决定元素属性的计算值。
* （3）使用值（理想状态值）：计算值是在不对文档进行排版的情况下，以最快速度处理得到的结果。但是有些值的计算只能在文档排版的时候才能决定，比如元素的宽度设为其包含块的某个百分比，那么决定其包含块的宽度之前，这个元素的宽度就不能决定。所以使用值是解决了剩下的依赖关系后，必要时计算出来的绝对值。
* （4）实际值（现实状态值）：原则上使用值就是在渲染时所采取的值，但在特定情况下UA可能无法理解这个值，比如UA可能只能渲染整数像素的边框，因此只能近似地计算宽度。实际值是UA对使用值经过近似处理后的结果。

##选择器
```css
    strong{
        color:red;
    }
```
上面这段代码被称为一条规则，这条规则以选择器strong开始，它选择要在DOM中哪些元素上使用这条规则。花括号中的部分称为声明，关键字```color```是一个属性，```red```是其对应值，同一个声明中的属性和值组成一个名值对，名值对用分号分隔。

######标签选择器
样式表中以标签名开头

######类选择器
样式表中类选择器以```.```开头

######ID选择器
样式表中ID选择器以```#```开头

如果多于一个规则指定了相同的属性值都应用到一个元素上，css规定拥有更高确定度的选择器优先级更高，ID选择器比类选择器更具确定度，类选择器比标签选择器更具确定度，它们有具体的特性值上面已经详细讲过。

> * 你也可以将多个选择器组合起来构成更确定的选择器。
> * 比如，选择器```.key```选中所有```class```属性为```key```的元素，选择器```p.key```选中所有```class```属性为```key```的```<p>```元素。
> * 除了```class```和```id```，你还可以用方括号指定其他属性，比如选择器```[type="button"]```选中所有```type```属性为```button```的元素。

######伪类选择器
css伪类是加在选择器后面的用来指定元素状态的关键字。比如，```:hover```会在鼠标悬停在选中元素上时应用相应样式。

伪类和伪元素不仅可以让你为符合某种文档结构的元素指定样式，还可以为符合某些外部条件的元素指定样式：浏览历史（比如是否访问过```:visited```），内容状态（```:checked```），鼠标位置（```:hover```）等

语法
```css
    selector:pseudo-class{
        property:value;
    }
```

伪类列表

* :link 选择未被访问过的链接并设置其样式，```:link```选择器不会设置已经访问过的链接的样式。
```css
    a:link{
        background-color:yellow;
    }
```
* :visited 已经访问过页面的链接设置样式，很奇怪为什么给其设置```background-color```或```font-size```属性没用。
* :active 点击链接时的样式，选择活动链接，并设置其样式。当你在一个链接上点击时，它就会成为活动的（激活的）。
* :hover 鼠标指针浮动到链接上时的样式，该选择器可用于所有元素，不只是链接。在css定义中，```:hover```必须位于```link```和```visited```之后（如果存在的话），原因权威指南上有讲过具体有点遗忘，记得整理。这样样式才能生效。
* :focus 选取获得焦点的元素，并设置其样式。接收键盘事件或其他用户输入的元素都允许```:focus```选择器。
```css
    /*在文本框中点击会看到黄色背景*/
    input:focus{
        background-color:yellow;
    }
```

* :first-child 选择属于其父元素的首个子元素，即目标是选择伪类冒号前面紧跟的元素。
```css
    /*选择所有是其父元素的第一个子元素的p元素下的每个i元素，
    或者这么理解：选择每个p中的每个i元素设置其样式，其中的p元素是其父元素的第一个子元素*/
    p:first-child i{
        background-color:yellow;
    }
```
```html
    <ul>
        <li>雪碧</li>
        <li>
            <ol>
                <li>one</li>
                <li>two</li>
            </ol>
        </li>
        <li>可口可乐</li>
    </ul>
```
```css
    /*选择是ul后代的名为li的元素，且该li元素是其父元素的首个元素
    最终选中“雪碧”和“one”*/
    ul li:first-child{
        background:yellow;
    }
    /*选择ul的直接后代名为li的元素，且该li元素是其父元素的首个元素
    最终选择只有“雪碧”*/
    ul>li:first-child{
        background:red;
    }
```
* :nth-child(n) 匹配属于其父元素的第n个子元素，且该元素是紧跟着冒号的那个元素（如果没说明冒号之前的元素，则```body```下的任意元素均有可能），n可以是数字，关键词或公式。该选择器不论元素的类型。n是相对于父元素的。
```css
    /*odd和even是可用于匹配下标是奇数或偶数的子元素的关键词，第一个子元素的下标是1*/
    /*选中“雪碧”“one”“可口可乐”*/
    li:nth-child(odd){
        background-color:red;
    }
    /*选中“two”*/
    ol>li:nth-child(even){
        background-color:red;
    }
    /*使用公式an+b描述表示周期的长度，n是计数器从0开始，b是偏移值*/
    /*:nth-child(0),:nth-child(3)，表示选第0个子元素nth-child(0)不存在，所以只选中第三个子元素li“可口可乐”*/
    li:nth-child(3n+0){
        background-color:yellow;
    }
``` 
* :nth-last-child(n) 匹配属于其父元素的第n个子元素的每个元素，不论元素类型，从最后一个元素开始计数。```odd```和```even```同样适用匹配下标，n也可以取公式（n从0开始计数）。
```css
    /*nth-last-child(0)，nth-last-child(3)从后面开始选择第0个元素不存在，选择第三个元素“雪碧”*/
    li:nth-last-child(3n+0){
        background-colr:red;
    }
```
* :nth-of-type(n) 选取父元素的特定类型的第n个子元素，先确定父元素下的特定类型的集合，再在特定类型的集合中找第n个元素。 所以这个n是相对于特定类型集合的。
```html
    <p>
        <li>A</li>
        <span>B</span>
        <span>C</span>
    </p>
```
```css
    /*选择p下第二个子元素且这个子元素是span。所以最终为B*/
    p span:nth-child(2){
        background-color:red;
    }
    /*选择p下span元素集合，再在span元素中找第二个项，所以为C*/
    p span:nth-of-type(2){
        background-colr:red;
    }
```
* :first-of-type 等同于nth-of-type(1)
```html
    <div>
        <p>A</p>
        <p>
            <span>B</span>
            <span>C</span>
        </p>
        <div>D</div>
    </div>
```
```css
    /*因为没有限制具体选择哪个类型的元素所以只要是祖先div元素下属于其父元素下某一类型元素的第一项都可以，
    <p>A</p>和<div>D</div>，<span></span>在不同级，最终选A，B，D*/
    div :first-of-type{
        background-color:red;
    }
```
* :last-of-type 等同于nth-of-type(n)，在它父元素子列表中最后一个给定类型的元素。
```html
    <p>
        <em>A</em>
        <span>
            <em>B</em>
        </span>
        <em>C</em>
    </p>
```
```css
    /*在它父元素子列表：有<p>下的em列表和<span>下的em列表，这两列表都符合在祖先元素p之下，所以选每组列表的最后一项为B和C*/
    p em:last-of-type{
        background-color:red;
    }
```
* :empty 代表没有子元素（子元素是指元素节点，文本节点（包括空格），注释和运行指令不考虑在内）的元素。
```html 
    <div><!--I will be red--></div>
    <div>test</div>
```
```css
    div:empty{
        background-color:red;
    }
```
* :target css3，匹配文档页面的url中某个标志符的目标元素即匹配相关url中#指向的元素。比如URL带有后面跟有锚名称（也不一定非得通过页面中a元素，在浏览器地址栏键入```http://xxxx.com#tab1```，且页面中某元素的id为"tab1"也可以，因为此时就会得到对应有的目标元素，即使直接使用```:target```不限定它是哪种类型的），如```href="#tab1"```，```:target```就是用来选取当前活动的目标元素即页面中id属性被设置为tab1的目标元素，此时可用```document.querySelector('#tab1:target')```获取到该目标元素。之前使用锚点可以实现单页跳转，但并不能直接体现样式的变化，使用target伪类可以像```:hover```等伪类一样对目标元素定义样式。
```html
    <div>
        <a href="#a">A</li>
        <a href="#b">B</li>
        <a href="#c">C</li>
    </div>
    <ul>
        <li id="a">a</li>
        <li id="b">b</li>
        <li id="c">c</li>
    </ul>
```
```css
   #a:target,#b:target,#c:target{
    background-color:red;
   }
```
target伪类使用场景：在页面上做跳转时要显示某种状态比如章节或评论的跳转；接受浏览器的```history```；css实现tabs切换，菜单等效果。
* :checked 表示任何radio(<input type="radio">)，checkbox(<input type="checkbox">)或option HTML元素("option")在一个HTML元素("select")元素选中或链接一个状态。用户可以改变在该元素上的状态，或选择一个不同的值,这种情况下:checked伪类不再适应于这个元素但仍是有关的一个。可用```document.querySelector(':target')```获取。但是属性应用不多经测试```color```，```border```等属性不适用。
```css
    /*任何被选中的元素*/
    :checked{
        width:50px;
        height:50px;
    }
    /*只能是type为radio的元素*/
    input[type="radio"]:checked{
        margin-left:25px;
    }
    /*页面上所有选中的select的选项*/
    option:checked{
        margin-left:10px;
    }
```
应用：隐藏的的radioboxs存储一些css布尔值，label元素的妙用可以不用紧跟<input>之后
```html
```
* :enabled 
* :disabled


##参考
[css入门教程](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Getting_started)

[w3c 分派属性值、层叠与继承](https://www.w3.org/html/ig/zh/wiki/CSS2/cascade)

[css继承性及其应用详解](http://developer.51cto.com/art/201009/224897_all.htm#585532-tsina-1-58356-7e393678b940a4d55500bf3feae3d2e9)

[css伪类与伪元素的区别及由来](http://swordair.com/origin-and-difference-between-css-pseudo-classes-and-pseudo-elements/)

[详解css属性-伪类和伪元素的区别](https://segmentfault.com/a/1190000000484493)

[css3选择器:nth-child和:nth-of-type之间的差异](http://www.zhangxinxu.com/wordpress/2011/06/css3%E9%80%89%E6%8B%A9%E5%99%A8nth-child%E5%92%8Cnth-of-type%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82/)

[css3 target伪类简介](https://www.qianduan.net/css3-target-pseudo-class-introduction/#tab2)

[css伪类中的:target的使用](http://www.wutongwei.com/front/infor_showone.tweb?id=189)
